"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sql_parser_1 = require("@joe-re/sql-parser");
const log4js_1 = __importDefault(require("log4js"));
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const logger = log4js_1.default.getLogger();
const FROM_KEYWORD = { label: 'FROM', kind: vscode_languageserver_types_1.CompletionItemKind.Text };
const CLAUSES = [
    { label: 'WHERE', kind: vscode_languageserver_types_1.CompletionItemKind.Text },
    { label: 'ORDER BY', kind: vscode_languageserver_types_1.CompletionItemKind.Text },
    { label: 'GROUP BY', kind: vscode_languageserver_types_1.CompletionItemKind.Text },
    { label: 'LIMIT', kind: vscode_languageserver_types_1.CompletionItemKind.Text }
];
function extractExpectedLiterals(expected) {
    return expected.filter(v => v.type === 'literal')
        .map(v => v.text)
        .filter((v, i, self) => self.indexOf(v) === i)
        .map(v => ({ label: v }));
}
function getLastToken(sql) {
    const match = sql.match(/^(?:.|\s)*[^A-z0-9](.*?)$/);
    if (!match) {
        return sql;
    }
    return match[1];
}
function getColumnRefByPos(columns, pos) {
    return columns.find(v => (v.location.start.line === pos.line + 1 && v.location.start.column <= pos.column) &&
        (v.location.end.line === pos.line + 1 && v.location.end.column >= pos.column));
}
function isPosInLocation(location, pos) {
    return (location.start.line === pos.line + 1 && location.start.column <= pos.column) &&
        (location.end.line === pos.line + 1 && location.end.column >= pos.column);
}
function getFromNodeByPos(fromNodes, pos) {
    return fromNodes.find(v => isPosInLocation(v.location, pos));
}
function toCompletionItemFromTable(table) {
    return {
        label: table.tableName,
        detail: `table ${table.tableName}`,
        kind: vscode_languageserver_types_1.CompletionItemKind.Text
    };
}
function toCompletionItemFromColumn(column) {
    return {
        label: column.columnName,
        detail: `column ${column.description}`,
        kind: vscode_languageserver_types_1.CompletionItemKind.Text
    };
}
function getTableAndColumnCondidates(tablePrefix, schema, option) {
    const tableCandidates = schema.filter(v => v.tableName.startsWith(tablePrefix)).map(v => toCompletionItemFromTable(v));
    const columnCandidates = Array.prototype.concat.apply([], schema.filter(v => tableCandidates.map(v => v.label).includes(v.tableName)).map(v => v.columns)).map((v) => toCompletionItemFromColumn(v));
    const candidates = [];
    if (!(option === null || option === void 0 ? void 0 : option.withoutTable)) {
        candidates.push(...tableCandidates);
    }
    if (!(option === null || option === void 0 ? void 0 : option.withoutColumn)) {
        candidates.push(...columnCandidates);
    }
    return candidates;
}
function isCursorOnFromClause(sql, pos) {
    var _a;
    try {
        const ast = sql_parser_1.parse(sql);
        return !!getFromNodeByPos(((_a = ast.from) === null || _a === void 0 ? void 0 : _a.tables) || [], pos);
    }
    catch (_e) {
        return false;
    }
}
function getCandidatedFromIncompleteSubquery(params) {
    let candidates = [];
    const { schema, incompleteSubquery, pos } = params;
    const parsedFromClause = getFromNodesFromClause(incompleteSubquery.text);
    try {
        sql_parser_1.parse(incompleteSubquery.text);
    }
    catch (e) {
        if (e.name !== 'SyntaxError') {
            throw e;
        }
        const fromText = incompleteSubquery.text;
        const newPos = parsedFromClause ? {
            line: pos.line - (incompleteSubquery.location.start.line - 1),
            column: pos.column - incompleteSubquery.location.start.column + 1
        } : { line: 0, column: 0 };
        candidates = complete(fromText, newPos, schema).candidates;
    }
    return candidates;
}
function createTablesFromFromNodes(fromNodes) {
    return fromNodes.reduce((p, c) => {
        if (c.type !== 'subquery') {
            return p;
        }
        if (!Array.isArray(c.subquery.columns)) {
            return p;
        }
        const columns = c.subquery.columns.map(v => {
            if (typeof v === 'string') {
                return null;
            }
            return { columnName: v.as || (v.expr.type === 'column_ref' && v.expr.column) || '', description: 'alias' };
        });
        return p.concat({ database: null, columns, tableName: c.as });
    }, []);
}
function getCandidatesFromError(target, schema, pos, e, fromNodes) {
    switch (e.message) {
        case 'EXPECTED COLUMN NAME': {
            return getTableAndColumnCondidates('', schema, { withoutTable: true });
        }
    }
    let candidates = extractExpectedLiterals(e.expected || []);
    const candidatesLiterals = candidates.map(v => v.label);
    if (candidatesLiterals.includes("'") || candidatesLiterals.includes('"')) {
        return [];
    }
    if (candidatesLiterals.includes('.')) {
        candidates = candidates.concat(schema.map(v => toCompletionItemFromTable(v)));
    }
    const lastChar = target[target.length - 1];
    logger.debug(`lastChar: ${lastChar}`);
    if (lastChar === '.') {
        const removedLastDotTarget = target.slice(0, target.length - 1);
        if (isCursorOnFromClause(removedLastDotTarget, { line: pos.line, column: pos.column - 1 })) {
            return [];
        }
        const tableName = getLastToken(removedLastDotTarget);
        const subqueryTables = createTablesFromFromNodes(fromNodes);
        const attachedAlias = schema.concat(subqueryTables).map(v => {
            const as = fromNodes.filter((v2) => v.tableName === v2.table).map(v => v.as);
            return Object.assign({}, v, { as: as ? as : [] });
        });
        let table = attachedAlias.find(v => v.tableName === tableName || v.as.includes(tableName));
        if (table) {
            candidates = table.columns.map(v => toCompletionItemFromColumn(v));
        }
    }
    return candidates;
}
function getFromNodesFromClause(sql) {
    try {
        return sql_parser_1.parseFromClause(sql);
    }
    catch (_e) {
        // no-op
        return null;
    }
}
function getRidOfAfterCursorString(sql, pos) {
    return sql.split('\n').filter((_v, idx) => pos.line >= idx).map((v, idx) => idx === pos.line ? v.slice(0, pos.column) : v).join('\n');
}
function completeDeleteStatement(ast, pos, schema) {
    if (isPosInLocation(ast.table.location, pos)) {
        return getTableAndColumnCondidates('', schema, { withoutColumn: true });
    }
    else if (ast.where && isPosInLocation(ast.where.expression.location, pos)) {
        return getTableAndColumnCondidates('', schema, { withoutTable: true });
    }
    return [];
}
function completeSelectStatement(ast, _pos, _schema) {
    let candidates = [];
    if (Array.isArray(ast.columns)) {
        const first = ast.columns[0];
        const rest = ast.columns.slice(1, ast.columns.length);
        const lastColumn = rest.reduce((p, c) => p.location.end.offset < c.location.end.offset ? c : p, first);
        if ((lastColumn.expr.type === 'column_ref' && FROM_KEYWORD.label.startsWith(lastColumn.expr.column)) ||
            (lastColumn.as && FROM_KEYWORD.label.startsWith(lastColumn.as))) {
            candidates.push(FROM_KEYWORD);
        }
    }
    return candidates;
}
function complete(sql, pos, schema = []) {
    var _a, _b, _c;
    logger.debug(`complete: ${sql}, ${JSON.stringify(pos)}`);
    let candidates = [];
    let error = null;
    const target = getRidOfAfterCursorString(sql, pos);
    logger.debug(`target: ${target}`);
    try {
        candidates = CLAUSES.concat([]);
        const ast = sql_parser_1.parse(target);
        logger.debug(`ast: ${JSON.stringify(ast)}`);
        if (ast.type === 'delete') {
            candidates = completeDeleteStatement(ast, pos, schema);
        }
        else {
            if (ast.type === 'select' && !ast.distinct) {
                candidates.push({ label: 'DISTINCT', kind: vscode_languageserver_types_1.CompletionItemKind.Text });
            }
            if (ast.type === 'select') {
                candidates = candidates.concat(completeSelectStatement(ast, pos, schema));
            }
            const columns = ast.columns;
            if (Array.isArray(columns)) {
                const selectColumnRefs = columns.map((v) => v.expr).filter((v) => !!v);
                const whereColumnRefs = ast.type === 'select' && ast.where || [];
                const columnRef = getColumnRefByPos(selectColumnRefs.concat(whereColumnRefs), pos);
                logger.debug(JSON.stringify(columnRef));
                if (columnRef) {
                    candidates = candidates.concat(getTableAndColumnCondidates(columnRef.table, schema));
                }
            }
            if (ast.type === 'select' && Array.isArray((_a = ast.from) === null || _a === void 0 ? void 0 : _a.tables)) {
                const fromTable = getFromNodeByPos(((_b = ast.from) === null || _b === void 0 ? void 0 : _b.tables) || [], pos);
                if (fromTable && fromTable.type === 'table') {
                    candidates = candidates.concat(schema.map(v => toCompletionItemFromTable(v)))
                        .concat([{ label: 'INNER JOIN' }, { label: 'LEFT JOIN' }]);
                    if (fromTable.join && !fromTable.on) {
                        candidates.push({ label: 'ON' });
                    }
                }
            }
        }
    }
    catch (e) {
        logger.debug('error');
        logger.debug(e);
        if (e.name !== 'SyntaxError') {
            throw e;
        }
        const parsedFromClause = getFromNodesFromClause(sql);
        const fromNodes = ((_c = parsedFromClause === null || parsedFromClause === void 0 ? void 0 : parsedFromClause.from) === null || _c === void 0 ? void 0 : _c.tables) || [];
        const fromNodeOnCursor = getFromNodeByPos(fromNodes || [], pos);
        if (fromNodeOnCursor && fromNodeOnCursor.type === 'incomplete_subquery') {
            candidates = getCandidatedFromIncompleteSubquery({
                sql,
                pos,
                incompleteSubquery: fromNodeOnCursor,
                schema
            });
        }
        else {
            candidates = getCandidatesFromError(target, schema, pos, e, fromNodes);
        }
        error = { label: e.name, detail: e.message, line: e.line, offset: e.offset };
    }
    const lastToken = getLastToken(target);
    logger.debug(`lastToken: ${lastToken}`);
    logger.debug(JSON.stringify(candidates));
    candidates = candidates.filter(v => v.label.startsWith(lastToken));
    return { candidates, error };
}
exports.default = complete;
//# sourceMappingURL=complete.js.map