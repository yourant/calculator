"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServer = exports.createServerWithConnection = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const cache_1 = __importDefault(require("./cache"));
const complete_1 = __importDefault(require("./complete"));
const createDiagnostics_1 = __importDefault(require("./createDiagnostics"));
const createConnection_1 = __importDefault(require("./createConnection"));
const yargs_1 = __importDefault(require("yargs"));
const SettingStore_1 = __importDefault(require("./SettingStore"));
const getDatabaseClient_1 = __importDefault(require("./database_libs/getDatabaseClient"));
const initializeLogging_1 = __importDefault(require("./initializeLogging"));
const sqlint_1 = require("sqlint");
const log4js_1 = __importDefault(require("log4js"));
const Sqlite3Client_1 = require("./database_libs/Sqlite3Client");
function createServerWithConnection(connection) {
    initializeLogging_1.default();
    const logger = log4js_1.default.getLogger();
    let documents = new vscode_languageserver_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
    documents.listen(connection);
    let schema = [];
    let hasConfigurationCapability = false;
    let rootPath = '';
    async function makeDiagnostics(document) {
        var _a;
        const lintConfig = hasConfigurationCapability && ((_a = (await connection.workspace.getConfiguration({
            section: 'sqlLanguageServer',
        }))) === null || _a === void 0 ? void 0 : _a.lint) || {};
        const hasRules = lintConfig.hasOwnProperty('rules');
        const diagnostics = createDiagnostics_1.default(document.uri, document.getText(), hasRules ? lintConfig : null);
        connection.sendDiagnostics(diagnostics);
    }
    documents.onDidChangeContent(async (params) => {
        logger.debug(`onDidChangeContent: ${params.document.uri}, ${params.document.version}`);
        makeDiagnostics(params.document);
    });
    connection.onInitialize((params) => {
        const capabilities = params.capabilities;
        hasConfigurationCapability = !!capabilities.workspace && !!capabilities.workspace.configuration;
        logger.debug(`onInitialize: ${params.rootPath}`);
        rootPath = params.rootPath || '';
        return {
            capabilities: {
                textDocumentSync: 1,
                completionProvider: {
                    resolveProvider: true,
                    triggerCharacters: ['.'],
                },
                codeActionProvider: true,
                executeCommandProvider: {
                    commands: [
                        'sqlLanguageServer.switchDatabaseConnection',
                        'sqlLanguageServer.fixAllFixableProblems'
                    ]
                }
            }
        };
    });
    connection.onInitialized(async () => {
        var _a;
        SettingStore_1.default.getInstance().on('change', async () => {
            logger.debug('onInitialize: receive change event from SettingStore');
            try {
                try {
                    connection.sendNotification('sqlLanguageServer.finishSetup', {
                        personalConfig: SettingStore_1.default.getInstance().getPersonalConfig(),
                        config: SettingStore_1.default.getInstance().getSetting()
                    });
                }
                catch (e) {
                    logger.error(e);
                }
                try {
                    const client = getDatabaseClient_1.default(SettingStore_1.default.getInstance().getSetting());
                    schema = await client.getSchema();
                    logger.debug("get schema");
                    logger.debug(JSON.stringify(schema));
                }
                catch (e) {
                    logger.error("failed to get schema info");
                    if (e instanceof Sqlite3Client_1.RequireSqlite3Error) {
                        connection.sendNotification('sqlLanguageServer.error', {
                            message: "Need to rebuild sqlite3 module."
                        });
                    }
                    throw e;
                }
            }
            catch (e) {
                logger.error(e);
            }
        });
        const connections = hasConfigurationCapability && ((_a = (await connection.workspace.getConfiguration({
            section: 'sqlLanguageServer',
        }))) === null || _a === void 0 ? void 0 : _a.connections) || [];
        if (connections.length > 0) {
            SettingStore_1.default.getInstance().setSettingFromWorkspaceConfig(connections);
        }
        else if (rootPath) {
            SettingStore_1.default.getInstance().setSettingFromFile(`${process.env.HOME}/.config/sql-language-server/.sqllsrc.json`, `${rootPath}/.sqllsrc.json`, rootPath || '');
        }
    });
    connection.onDidChangeConfiguration(change => {
        var _a, _b, _c, _d, _e;
        logger.debug('onDidChangeConfiguration', JSON.stringify(change));
        if (!hasConfigurationCapability) {
            return;
        }
        const connections = (_c = (_b = (_a = change.settings) === null || _a === void 0 ? void 0 : _a.sqlLanguageServer) === null || _b === void 0 ? void 0 : _b.connections) !== null && _c !== void 0 ? _c : [];
        if (connections.length > 0) {
            SettingStore_1.default.getInstance().setSettingFromWorkspaceConfig(connections);
        }
        const lint = (_e = (_d = change.settings) === null || _d === void 0 ? void 0 : _d.sqlLanguageServer) === null || _e === void 0 ? void 0 : _e.lint;
        if (lint === null || lint === void 0 ? void 0 : lint.rules) {
            documents.all().forEach(v => {
                makeDiagnostics(v);
            });
        }
    });
    connection.onCompletion((docParams) => {
        var _a;
        let text = (_a = documents.get(docParams.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.getText();
        if (!text) {
            return [];
        }
        logger.debug(text || '');
        const candidates = complete_1.default(text, {
            line: docParams.position.line,
            column: docParams.position.character
        }, schema).candidates;
        logger.debug(candidates.map(v => v.label).join(","));
        return candidates;
    });
    connection.onCodeAction(params => {
        const lintResult = cache_1.default.findLintCacheByRange(params.textDocument.uri, params.range);
        if (!lintResult) {
            return [];
        }
        const document = documents.get(params.textDocument.uri);
        if (!document) {
            return [];
        }
        const text = document.getText();
        if (!text) {
            return [];
        }
        function toPosition(text, offset) {
            const lines = text.slice(0, offset).split('\n');
            return vscode_languageserver_types_1.Position.create(lines.length - 1, lines[lines.length - 1].length);
        }
        const fixes = Array.isArray(lintResult.lint.fix) ? lintResult.lint.fix : [lintResult.lint.fix];
        if (fixes.length === 0) {
            return [];
        }
        const action = vscode_languageserver_types_1.CodeAction.create(`fix: ${lintResult.diagnostic.message}`, {
            documentChanges: [
                vscode_languageserver_types_1.TextDocumentEdit.create({ uri: params.textDocument.uri, version: document.version }, fixes.map(v => {
                    const edit = v.range.startOffset === v.range.endOffset
                        ? vscode_languageserver_types_1.TextEdit.insert(toPosition(text, v.range.startOffset), v.text)
                        : vscode_languageserver_types_1.TextEdit.replace({
                            start: toPosition(text, v.range.startOffset),
                            end: toPosition(text, v.range.endOffset)
                        }, v.text);
                    return edit;
                }))
            ]
        }, vscode_languageserver_types_1.CodeActionKind.QuickFix);
        action.diagnostics = params.context.diagnostics;
        return [action];
    });
    connection.onCompletionResolve((item) => {
        return item;
    });
    connection.onExecuteCommand((request) => {
        logger.debug(`received executeCommand request: ${request.command}, ${request.arguments}`);
        if (request.command === 'switchDatabaseConnection') {
            try {
                SettingStore_1.default.getInstance().changeConnection(request.arguments && request.arguments[0] || '');
            }
            catch (e) {
                connection.sendNotification('sqlLanguageServer.error', {
                    message: e.message
                });
            }
        }
        else if (request.command === 'fixAllFixableProblems') {
            const uri = request.arguments ? request.arguments[0] : null;
            if (!uri) {
                connection.sendNotification('sqlLanguageServer.error', {
                    message: 'fixAllFixableProblems: Need to specify uri'
                });
                return;
            }
            const document = documents.get(uri);
            const text = document === null || document === void 0 ? void 0 : document.getText();
            if (!text) {
                logger.debug('Failed to get text');
                return;
            }
            const result = JSON.parse(sqlint_1.lint({ formatType: 'json', text, fix: true }));
            if (result.length === 0 && result[0].fixedText) {
                logger.debug("There's no fixable problems");
                return;
            }
            logger.debug('Fix all fixable problems', text, result[0].fixedText);
            connection.workspace.applyEdit({
                documentChanges: [
                    vscode_languageserver_types_1.TextDocumentEdit.create({ uri, version: document.version }, [
                        vscode_languageserver_types_1.TextEdit.replace({
                            start: vscode_languageserver_types_1.Position.create(0, 0),
                            end: vscode_languageserver_types_1.Position.create(Number.MAX_VALUE, Number.MAX_VALUE)
                        }, result[0].fixedText)
                    ])
                ]
            });
        }
    });
    connection.listen();
    logger.info('start sql-languager-server');
    return connection;
}
exports.createServerWithConnection = createServerWithConnection;
function createServer() {
    let connection = createConnection_1.default(yargs_1.default.argv.method || 'node-ipc');
    return createServerWithConnection(connection);
}
exports.createServer = createServer;
//# sourceMappingURL=createServer.js.map